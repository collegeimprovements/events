defmodule Events.Schema.Validation.Advanced do
  @moduledoc """
  Advanced validation helpers for schema fields.
  Includes array item validation, date/time validation, and database constraints.
  """

  import Ecto.Changeset

  @doc """
  Validate array items match specific criteria.
  """
  def validate_array_items(changeset, field_name, opts) do
    case get_change(changeset, field_name) do
      nil ->
        changeset

      items when is_list(items) ->
        changeset
        |> validate_item_format(field_name, items, opts)
        |> validate_item_range(field_name, items, opts)
        |> validate_unique_items(field_name, items, opts)

      _ ->
        changeset
    end
  end

  defp validate_item_format(changeset, field_name, items, opts) do
    case opts[:item_format] do
      nil ->
        changeset

      %Regex{} = regex ->
        invalid = Enum.reject(items, fn item -> is_binary(item) && String.match?(item, regex) end)

        if invalid != [] do
          add_error(changeset, field_name, "contains invalid items: #{inspect(invalid)}")
        else
          changeset
        end
    end
  end

  defp validate_item_range(changeset, field_name, items, opts) do
    min = opts[:item_min]
    max = opts[:item_max]

    if (min || max) && Enum.all?(items, &is_number/1) do
      invalid =
        Enum.filter(items, fn item ->
          (min && item < min) || (max && item > max)
        end)

      if invalid != [] do
        add_error(changeset, field_name, "contains out of range items: #{inspect(invalid)}")
      else
        changeset
      end
    else
      changeset
    end
  end

  defp validate_unique_items(changeset, field_name, items, opts) do
    if opts[:unique_items] do
      if length(items) != length(Enum.uniq(items)) do
        add_error(changeset, field_name, "must have unique items")
      else
        changeset
      end
    else
      changeset
    end
  end

  @doc """
  Validate date/time fields.
  """
  def validate_datetime(changeset, field_name, field_type, opts)
      when field_type in [
             :date,
             :time,
             :naive_datetime,
             :naive_datetime_usec,
             :utc_datetime,
             :utc_datetime_usec
           ] do
    changeset
    |> validate_past_future(field_name, opts)
    |> validate_datetime_range(field_name, opts)
  end

  def validate_datetime(changeset, _field_name, _field_type, _opts), do: changeset

  defp validate_past_future(changeset, field_name, opts) do
    case get_change(changeset, field_name) do
      nil ->
        changeset

      value ->
        now = DateTime.utc_now()

        cond do
          opts[:past] && compare_datetime(value, now) != :lt ->
            add_error(changeset, field_name, "must be in the past")

          opts[:future] && compare_datetime(value, now) != :gt ->
            add_error(changeset, field_name, "must be in the future")

          true ->
            changeset
        end
    end
  end

  defp validate_datetime_range(changeset, field_name, opts) do
    case get_change(changeset, field_name) do
      nil ->
        changeset

      value ->
        changeset
        |> validate_datetime_after(field_name, value, opts[:after])
        |> validate_datetime_before(field_name, value, opts[:before])
    end
  end

  defp validate_datetime_after(changeset, _field_name, _value, nil), do: changeset

  defp validate_datetime_after(changeset, field_name, value, after_value) do
    compare_value = resolve_datetime_value(after_value)

    if compare_datetime(value, compare_value) != :gt do
      add_error(changeset, field_name, "must be after #{inspect(compare_value)}")
    else
      changeset
    end
  end

  defp validate_datetime_before(changeset, _field_name, _value, nil), do: changeset

  defp validate_datetime_before(changeset, field_name, value, before_value) do
    compare_value = resolve_datetime_value(before_value)

    if compare_datetime(value, compare_value) != :lt do
      add_error(changeset, field_name, "must be before #{inspect(compare_value)}")
    else
      changeset
    end
  end

  defp resolve_datetime_value({:now, opts}) do
    now = DateTime.utc_now()
    add_time_offset(now, opts)
  end

  defp resolve_datetime_value({:today, opts}) do
    today = Date.utc_today()
    add_date_offset(today, opts)
  end

  defp resolve_datetime_value(value), do: value

  defp add_time_offset(datetime, opts) do
    datetime
    |> maybe_add_seconds(opts[:seconds])
    |> maybe_add_minutes(opts[:minutes])
    |> maybe_add_hours(opts[:hours])
    |> maybe_add_days(opts[:days])
  end

  defp add_date_offset(date, opts) do
    if days = opts[:days] do
      Date.add(date, days)
    else
      date
    end
  end

  defp maybe_add_seconds(dt, nil), do: dt
  defp maybe_add_seconds(dt, seconds), do: DateTime.add(dt, seconds, :second)

  defp maybe_add_minutes(dt, nil), do: dt
  defp maybe_add_minutes(dt, minutes), do: DateTime.add(dt, minutes * 60, :second)

  defp maybe_add_hours(dt, nil), do: dt
  defp maybe_add_hours(dt, hours), do: DateTime.add(dt, hours * 3600, :second)

  defp maybe_add_days(dt, nil), do: dt
  defp maybe_add_days(dt, days), do: DateTime.add(dt, days * 86400, :second)

  defp compare_datetime(%Date{} = d1, %Date{} = d2) do
    case Date.compare(d1, d2) do
      :lt -> :lt
      :eq -> :eq
      :gt -> :gt
    end
  end

  defp compare_datetime(%DateTime{} = dt1, %DateTime{} = dt2) do
    case DateTime.compare(dt1, dt2) do
      :lt -> :lt
      :eq -> :eq
      :gt -> :gt
    end
  end

  defp compare_datetime(%NaiveDateTime{} = ndt1, %NaiveDateTime{} = ndt2) do
    case NaiveDateTime.compare(ndt1, ndt2) do
      :lt -> :lt
      :eq -> :eq
      :gt -> :gt
    end
  end

  # Convert between types for comparison
  defp compare_datetime(%Date{} = d, %DateTime{} = dt) do
    date_from_dt = DateTime.to_date(dt)
    compare_datetime(d, date_from_dt)
  end

  defp compare_datetime(%DateTime{} = dt, %Date{} = d) do
    date_from_dt = DateTime.to_date(dt)
    compare_datetime(date_from_dt, d)
  end

  defp compare_datetime(_, _), do: :eq

  @doc """
  Apply database constraints validations.
  """
  def apply_constraints(changeset, field_name, opts) do
    changeset
    |> maybe_add_unique_constraint(field_name, opts)
    |> maybe_add_foreign_key_constraint(field_name, opts)
    |> maybe_add_check_constraint(field_name, opts)
  end

  defp maybe_add_unique_constraint(changeset, field_name, opts) do
    case opts[:unique] do
      true ->
        unique_constraint(changeset, field_name)

      fields when is_list(fields) ->
        # Composite unique constraint
        unique_constraint(changeset, field_name, name: constraint_name(fields, :unique))

      _ ->
        changeset
    end
  end

  defp maybe_add_foreign_key_constraint(changeset, field_name, opts) do
    if opts[:foreign_key] do
      foreign_key_constraint(changeset, field_name)
    else
      changeset
    end
  end

  defp maybe_add_check_constraint(changeset, field_name, opts) do
    if constraint = opts[:check] do
      check_constraint(changeset, field_name,
        name: constraint_name([field_name], :check),
        message: constraint
      )
    else
      changeset
    end
  end

  defp constraint_name(fields, type) do
    fields_str = fields |> Enum.map(&to_string/1) |> Enum.join("_")
    "#{fields_str}_#{type}"
  end

  @doc """
  Apply cross-field validations.
  """
  def apply_cross_field_validations(changeset, validations) when is_list(validations) do
    Enum.reduce(validations, changeset, fn validation, acc ->
      apply_cross_field_validation(acc, validation)
    end)
  end

  def apply_cross_field_validations(changeset, _), do: changeset

  defp apply_cross_field_validation(changeset, {:confirmation, field, opts}) do
    match_field = opts[:match] || :"#{field}_confirmation"
    validate_confirmation(changeset, field, confirmation: match_field)
  end

  defp apply_cross_field_validation(changeset, {:require_if, field, opts}) do
    case opts[:when] do
      {:field, other_field, equals: value} ->
        if get_field(changeset, other_field) == value do
          validate_required(changeset, [field])
        else
          changeset
        end

      {:field, other_field, is_set: true} ->
        if get_field(changeset, other_field) != nil do
          validate_required(changeset, [field])
        else
          changeset
        end

      _ ->
        changeset
    end
  end

  defp apply_cross_field_validation(changeset, {:one_of, fields}) do
    has_value = Enum.any?(fields, fn field -> get_field(changeset, field) != nil end)

    if has_value do
      changeset
    else
      add_error(changeset, hd(fields), "at least one of #{inspect(fields)} must be present")
    end
  end

  defp apply_cross_field_validation(changeset, {:compare, field1, comparison: {op, field2}}) do
    val1 = get_field(changeset, field1)
    val2 = get_field(changeset, field2)

    if val1 && val2 do
      valid =
        case op do
          :greater_than -> val1 > val2
          :greater_than_or_equal_to -> val1 >= val2
          :less_than -> val1 < val2
          :less_than_or_equal_to -> val1 <= val2
          :equal_to -> val1 == val2
          :not_equal_to -> val1 != val2
          _ -> true
        end

      if valid do
        changeset
      else
        add_error(changeset, field1, "must be #{op} #{field2}")
      end
    else
      changeset
    end
  end

  defp apply_cross_field_validation(changeset, _), do: changeset
end
