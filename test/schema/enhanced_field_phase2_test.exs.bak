defmodule Events.Schema.EnhancedFieldPhase2Test do
  use ExUnit.Case, async: true

  # Test module for custom error messages
  defmodule TestCustomMessages do
    use Events.Schema

    schema "test_custom_messages" do
      field :name, :string,
        required: true,
        min_length: {2, message: "name is too short"},
        max_length: {100, message: "name is too long"}

      field :age, :integer,
        min: {18, message: "must be an adult"},
        max: {120, message: "age seems unrealistic"}

      field :email, :string, format: {:email, message: "provide a valid email address"}
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> Ecto.Changeset.validate_required(__required_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for message map
  defmodule TestMessageMap do
    use Events.Schema

    schema "test_message_map" do
      field :username, :string,
        required: true,
        min_length: 3,
        max_length: 20,
        messages: %{
          length: "username must be between 3 and 20 characters",
          min: "username is too short",
          max: "username is too long"
        }
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> Ecto.Changeset.validate_required(__required_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for map validations
  defmodule TestMapValidations do
    use Events.Schema

    schema "test_map_validations" do
      field :config, :map,
        required_keys: [:host, :port],
        forbidden_keys: [:password],
        min_keys: 2,
        max_keys: 10

      field :settings, :map, required_keys: [:theme]
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for array item validations
  defmodule TestArrayItemValidations do
    use Events.Schema

    schema "test_array_items" do
      field :tags, {:array, :string},
        min_length: 1,
        max_length: 5,
        unique_items: true,
        item_format: ~r/^[a-z0-9-]+$/

      field :scores, {:array, :integer},
        item_min: 0,
        item_max: 100,
        unique_items: true

      field :categories, {:array, :string}, in: ["tech", "health", "finance", "education"]
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for date/time validations
  defmodule TestDateTimeValidations do
    use Events.Schema

    schema "test_datetime" do
      field :birth_date, :date, past: true
      field :appointment, :utc_datetime, future: true
      field :event_start, :utc_datetime, after: {:now, hours: 1}
      field :deadline, :date, before: {:today, days: 30}
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for multiple normalizations
  defmodule TestMultipleNormalizations do
    use Events.Schema

    schema "test_normalizations" do
      field :username, :string, normalize: [:trim, :downcase]
      field :title, :string, normalize: [:trim, :squish, :titlecase]
      field :slug, :string, normalize: [:trim, :slugify]
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
    end
  end

  # Test module for cross-field validations
  defmodule TestCrossField do
    use Events.Schema

    schema "test_cross_field" do
      field :password, :string
      field :password_confirmation, :string
      field :shipping_address, :string
      field :use_billing_address, :boolean
      field :min_price, :integer
      field :max_price, :integer
      field :email, :string
      field :phone, :string
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
      |> apply_cross_validations()
    end

    defp apply_cross_validations(changeset) do
      Events.Schema.Validation.Advanced.apply_cross_field_validations(changeset, [
        {:confirmation, :password, match: :password_confirmation},
        {:require_if, :shipping_address, when: {:field, :use_billing_address, equals: false}},
        {:one_of, [:email, :phone]},
        {:compare, :max_price, comparison: {:greater_than, :min_price}}
      ])
    end
  end

  # Test module for conditional validation
  defmodule TestConditionalValidation do
    use Events.Schema

    schema "test_conditional" do
      field :discount_code, :string,
        min_length: 5,
        validate_if: {__MODULE__, :should_validate_discount}

      field :apply_discount, :boolean, default: false
    end

    def changeset(schema, attrs) do
      schema
      |> Ecto.Changeset.cast(attrs, __cast_fields__())
      |> __apply_field_validations__()
    end

    def should_validate_discount(changeset) do
      Ecto.Changeset.get_field(changeset, :apply_discount) == true
    end
  end

  describe "custom error messages with tuple syntax" do
    test "uses custom message from tuple for min_length" do
      changeset = TestCustomMessages.changeset(%TestCustomMessages{}, %{name: "A"})

      refute changeset.valid?
      assert %{name: ["name is too short"]} = errors_on(changeset)
    end

    test "uses custom message from tuple for max" do
      changeset = TestCustomMessages.changeset(%TestCustomMessages{}, %{age: 150})

      refute changeset.valid?
      assert %{age: ["age seems unrealistic"]} = errors_on(changeset)
    end

    test "uses custom message from tuple for format" do
      changeset =
        TestCustomMessages.changeset(%TestCustomMessages{}, %{
          name: "John",
          email: "not-an-email"
        })

      refute changeset.valid?
      assert %{email: ["provide a valid email address"]} = errors_on(changeset)
    end
  end

  describe "messages map" do
    test "uses messages from messages map" do
      changeset = TestMessageMap.changeset(%TestMessageMap{}, %{username: "ab"})

      refute changeset.valid?
      # Should use either the specific :min or general :length message
      errors = errors_on(changeset)
      assert Map.has_key?(errors, :username)
    end
  end

  describe "map validations" do
    test "validates required keys" do
      changeset =
        TestMapValidations.changeset(%TestMapValidations{}, %{
          config: %{host: "localhost"}
        })

      refute changeset.valid?
      assert %{config: errors} = errors_on(changeset)
      assert Enum.any?(errors, fn error -> error =~ "missing required keys" end)
    end

    test "validates forbidden keys" do
      changeset =
        TestMapValidations.changeset(%TestMapValidations{}, %{
          config: %{host: "localhost", port: 8080, password: "secret"}
        })

      refute changeset.valid?
      assert %{config: [error]} = errors_on(changeset)
      assert error =~ "forbidden keys"
    end

    test "validates min keys" do
      changeset =
        TestMapValidations.changeset(%TestMapValidations{}, %{
          config: %{host: "localhost"}
        })

      refute changeset.valid?
      assert %{config: errors} = errors_on(changeset)
      assert Enum.any?(errors, fn e -> e =~ "at least" end)
    end

    test "validates max keys" do
      config = Map.new(1..15, fn i -> {"key#{i}", "value#{i}"} end)
      changeset = TestMapValidations.changeset(%TestMapValidations{}, %{config: config})

      refute changeset.valid?
      assert %{config: errors} = errors_on(changeset)
      assert Enum.any?(errors, fn e -> e =~ "at most" end)
    end

    test "accepts valid map" do
      changeset =
        TestMapValidations.changeset(%TestMapValidations{}, %{
          config: %{host: "localhost", port: 8080, database: "mydb"}
        })

      assert changeset.valid?
    end
  end

  describe "array item validations" do
    test "validates item format" do
      changeset =
        TestArrayItemValidations.changeset(%TestArrayItemValidations{}, %{
          tags: ["valid-tag", "Invalid Tag!"]
        })

      refute changeset.valid?
      assert %{tags: [error]} = errors_on(changeset)
      assert error =~ "invalid items"
    end

    test "validates item range for numbers" do
      changeset =
        TestArrayItemValidations.changeset(%TestArrayItemValidations{}, %{
          scores: [50, 75, 150]
        })

      refute changeset.valid?
      assert %{scores: [error]} = errors_on(changeset)
      assert error =~ "out of range"
    end

    test "validates unique items" do
      changeset =
        TestArrayItemValidations.changeset(%TestArrayItemValidations{}, %{
          tags: ["elixir", "phoenix", "elixir"]
        })

      refute changeset.valid?
      assert %{tags: [error]} = errors_on(changeset)
      assert error =~ "unique items"
    end

    test "validates subset with :in option" do
      changeset =
        TestArrayItemValidations.changeset(%TestArrayItemValidations{}, %{
          categories: ["tech", "sports"]
        })

      refute changeset.valid?
      assert %{categories: _} = errors_on(changeset)
    end

    test "accepts valid array items" do
      changeset =
        TestArrayItemValidations.changeset(%TestArrayItemValidations{}, %{
          tags: ["elixir", "phoenix", "ecto"],
          scores: [85, 90, 95],
          categories: ["tech", "education"]
        })

      assert changeset.valid?
    end
  end

  describe "date/time validations" do
    test "validates past dates" do
      tomorrow = Date.add(Date.utc_today(), 1)

      changeset =
        TestDateTimeValidations.changeset(%TestDateTimeValidations{}, %{
          birth_date: tomorrow
        })

      refute changeset.valid?
      assert %{birth_date: [error]} = errors_on(changeset)
      assert error =~ "past"
    end

    test "validates future dates" do
      yesterday = DateTime.add(DateTime.utc_now(), -86400, :second)

      changeset =
        TestDateTimeValidations.changeset(%TestDateTimeValidations{}, %{
          appointment: yesterday
        })

      refute changeset.valid?
      assert %{appointment: [error]} = errors_on(changeset)
      assert error =~ "future"
    end

    test "accepts valid past date" do
      past_date = Date.add(Date.utc_today(), -365)

      changeset =
        TestDateTimeValidations.changeset(%TestDateTimeValidations{}, %{
          birth_date: past_date
        })

      # Should not have birth_date errors (might have other required field errors)
      errors = errors_on(changeset)
      refute Map.has_key?(errors, :birth_date)
    end

    test "accepts valid future datetime" do
      future_datetime = DateTime.add(DateTime.utc_now(), 86400, :second)

      changeset =
        TestDateTimeValidations.changeset(%TestDateTimeValidations{}, %{
          appointment: future_datetime
        })

      errors = errors_on(changeset)
      refute Map.has_key?(errors, :appointment)
    end
  end

  describe "multiple normalizations" do
    test "applies normalizations in order" do
      changeset =
        TestMultipleNormalizations.changeset(%TestMultipleNormalizations{}, %{
          username: "  JohnDoe  "
        })

      assert Ecto.Changeset.get_change(changeset, :username) == "johndoe"
    end

    test "applies trim, squish, and titlecase" do
      changeset =
        TestMultipleNormalizations.changeset(%TestMultipleNormalizations{}, %{
          title: "  hello   world  "
        })

      assert Ecto.Changeset.get_change(changeset, :title) == "Hello World"
    end

    test "applies slugify normalization" do
      changeset =
        TestMultipleNormalizations.changeset(%TestMultipleNormalizations{}, %{
          slug: "  Hello World!  "
        })

      slug = Ecto.Changeset.get_change(changeset, :slug)
      assert slug == "hello-world"
    end
  end

  describe "cross-field validations" do
    test "validates password confirmation" do
      changeset =
        TestCrossField.changeset(%TestCrossField{}, %{
          password: "secret123",
          password_confirmation: "different"
        })

      refute changeset.valid?
      assert %{password_confirmation: _} = errors_on(changeset)
    end

    test "validates require_if condition" do
      changeset =
        TestCrossField.changeset(%TestCrossField{}, %{
          use_billing_address: false
        })

      refute changeset.valid?
      assert %{shipping_address: _} = errors_on(changeset)
    end

    test "validates one_of requirement" do
      changeset = TestCrossField.changeset(%TestCrossField{}, %{})

      refute changeset.valid?
      errors = errors_on(changeset)
      assert Map.has_key?(errors, :email) or Map.has_key?(errors, :phone)
    end

    test "validates comparison between fields" do
      changeset =
        TestCrossField.changeset(%TestCrossField{}, %{
          min_price: 100,
          max_price: 50,
          email: "test@example.com"
        })

      refute changeset.valid?
      assert %{max_price: [error]} = errors_on(changeset)
      assert error =~ "greater_than"
    end

    test "accepts valid cross-field data" do
      changeset =
        TestCrossField.changeset(%TestCrossField{}, %{
          password: "secret123",
          password_confirmation: "secret123",
          use_billing_address: true,
          min_price: 50,
          max_price: 100,
          email: "test@example.com"
        })

      assert changeset.valid?
    end
  end

  describe "conditional validation" do
    test "skips validation when condition is false" do
      changeset =
        TestConditionalValidation.changeset(%TestConditionalValidation{}, %{
          apply_discount: false,
          discount_code: "ABC"
        })

      # Should be valid because validation is skipped when apply_discount is false
      assert changeset.valid?
    end

    test "applies validation when condition is true" do
      changeset =
        TestConditionalValidation.changeset(%TestConditionalValidation{}, %{
          apply_discount: true,
          discount_code: "ABC"
        })

      # Should be invalid because discount_code is too short (< 5)
      refute changeset.valid?
      assert %{discount_code: _} = errors_on(changeset)
    end

    test "accepts valid conditional data" do
      changeset =
        TestConditionalValidation.changeset(%TestConditionalValidation{}, %{
          apply_discount: true,
          discount_code: "SAVE20"
        })

      assert changeset.valid?
    end
  end

  # Helper to get errors as a map
  defp errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end
