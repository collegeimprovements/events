defmodule OmScheduler.Workflow.Store do
  @moduledoc """
  Database-backed store for workflow definitions and executions.

  This module provides persistence for:
  - Workflow definitions (versioned)
  - Workflow executions (with full history)
  - Step executions (detailed tracking)

  ## Usage

      # Save a workflow definition
      {:ok, _} = Store.save_workflow(workflow)

      # Create an execution
      {:ok, exec} = Store.create_execution(execution)

      # Update execution as it progresses
      {:ok, _} = Store.update_execution(exec)

      # Query executions
      {:ok, execs} = Store.list_executions(:my_workflow, state: :running)
  """

  import Ecto.Query
  require Logger

  alias OmScheduler.Workflow
  alias OmScheduler.Workflow.Execution

  alias OmScheduler.Workflow.Schemas.{
    WorkflowDefinition,
    WorkflowExecution,
    WorkflowStepExecution
  }

  alias OmScheduler.Config

  # ============================================
  # Configuration
  # ============================================

  defp repo do
    Config.get()[:repo] || OmScheduler.Config.repo()
  end

  defp prefix do
    Config.get()[:prefix] || "public"
  end

  # ============================================
  # Workflow Definition Operations
  # ============================================

  @doc """
  Saves a workflow definition to the database.

  If a workflow with the same name exists, creates a new version.
  """
  @spec save_workflow(Workflow.t()) :: {:ok, WorkflowDefinition.t()} | {:error, term()}
  def save_workflow(%Workflow{} = workflow) do
    attrs = WorkflowDefinition.from_workflow(workflow)

    # Get the latest version for this workflow
    version = get_latest_version(workflow.name) + 1
    attrs = Map.put(attrs, :version, version)

    %WorkflowDefinition{}
    |> WorkflowDefinition.changeset(attrs)
    |> repo().insert(prefix: prefix())
  end

  @doc """
  Gets a workflow definition by name.

  Returns the latest version by default.
  """
  @spec get_workflow(atom(), keyword()) :: {:ok, Workflow.t()} | {:error, :not_found}
  def get_workflow(name, opts \\ []) when is_atom(name) do
    version = Keyword.get(opts, :version)
    name_string = Atom.to_string(name)

    query =
      from(w in WorkflowDefinition,
        where: w.name == ^name_string,
        order_by: [desc: w.version],
        limit: 1
      )

    query =
      if version do
        from(w in query, where: w.version == ^version)
      else
        query
      end

    case repo().one(query, prefix: prefix()) do
      nil -> {:error, :not_found}
      schema -> {:ok, WorkflowDefinition.to_workflow(schema)}
    end
  rescue
    ArgumentError ->
      # String.to_existing_atom failed - workflow not loaded
      {:error, :not_found}
  end

  @doc """
  Lists all workflow definitions.
  """
  @spec list_workflows(keyword()) :: [WorkflowDefinition.t()]
  def list_workflows(opts \\ []) do
    tags = Keyword.get(opts, :tags, [])
    trigger_type = Keyword.get(opts, :trigger_type)
    enabled = Keyword.get(opts, :enabled)

    # Get latest version of each workflow using a subquery
    latest_versions =
      from(w in WorkflowDefinition,
        group_by: w.name,
        select: %{name: w.name, version: max(w.version)}
      )

    query =
      from(w in WorkflowDefinition,
        join: lv in subquery(latest_versions),
        on: w.name == lv.name and w.version == lv.version,
        order_by: [asc: w.name]
      )

    query =
      query
      |> maybe_filter_tags(tags)
      |> maybe_filter_trigger(trigger_type)
      |> maybe_filter_enabled(enabled)

    repo().all(query, prefix: prefix())
  end

  @doc """
  Deletes a workflow definition (all versions).
  """
  @spec delete_workflow(atom()) :: {:ok, non_neg_integer()} | {:error, term()}
  def delete_workflow(name) when is_atom(name) do
    name_string = Atom.to_string(name)

    query = from(w in WorkflowDefinition, where: w.name == ^name_string)

    case repo().delete_all(query, prefix: prefix()) do
      {count, _} -> {:ok, count}
    end
  end

  defp get_latest_version(name) when is_atom(name) do
    name_string = Atom.to_string(name)

    query =
      from(w in WorkflowDefinition,
        where: w.name == ^name_string,
        select: max(w.version)
      )

    repo().one(query, prefix: prefix()) || 0
  end

  # ============================================
  # Execution Operations
  # ============================================

  @doc """
  Creates a new workflow execution record.

  Note: The execution ID is generated by the database if not a valid UUID.
  The returned schema will have the database-generated ID.
  """
  @spec create_execution(Execution.t(), binary() | nil) ::
          {:ok, WorkflowExecution.t()} | {:error, term()}
  def create_execution(%Execution{} = execution, workflow_definition_id \\ nil) do
    attrs = WorkflowExecution.from_execution(execution, workflow_definition_id)

    # If the execution ID is not a valid UUID, let the database generate one
    attrs =
      case Ecto.UUID.cast(execution.id) do
        {:ok, uuid} -> Map.put(attrs, :id, uuid)
        # Let DB generate
        :error -> attrs
      end

    %WorkflowExecution{}
    |> WorkflowExecution.changeset(attrs)
    |> repo().insert(prefix: prefix(), returning: true)
  end

  @doc """
  Gets an execution by ID.
  """
  @spec get_execution(String.t()) :: {:ok, Execution.t()} | {:error, :not_found}
  def get_execution(execution_id) do
    # Try to cast to UUID first
    case Ecto.UUID.cast(execution_id) do
      {:ok, uuid} ->
        case repo().get(WorkflowExecution, uuid, prefix: prefix()) do
          nil -> {:error, :not_found}
          schema -> {:ok, WorkflowExecution.to_execution(schema)}
        end

      :error ->
        {:error, :not_found}
    end
  rescue
    ArgumentError ->
      {:error, :not_found}
  end

  @doc """
  Updates an execution record.
  """
  @spec update_execution(Execution.t()) :: {:ok, WorkflowExecution.t()} | {:error, term()}
  def update_execution(%Execution{id: id} = execution) do
    case Ecto.UUID.cast(id) do
      {:ok, uuid} ->
        case repo().get(WorkflowExecution, uuid, prefix: prefix()) do
          nil ->
            # Create if not exists
            create_execution(execution)

          schema ->
            attrs = WorkflowExecution.from_execution(execution)

            schema
            |> WorkflowExecution.changeset(attrs)
            |> repo().update(prefix: prefix())
        end

      :error ->
        # Non-UUID ID, create new with database-generated ID
        create_execution(execution)
    end
  end

  @doc """
  Deletes an execution record.
  """
  @spec delete_execution(String.t()) :: :ok | {:error, :not_found}
  def delete_execution(execution_id) do
    case Ecto.UUID.cast(execution_id) do
      {:ok, uuid} ->
        case repo().get(WorkflowExecution, uuid, prefix: prefix()) do
          nil ->
            {:error, :not_found}

          schema ->
            repo().delete(schema, prefix: prefix())
            :ok
        end

      :error ->
        {:error, :not_found}
    end
  end

  @doc """
  Lists executions for a workflow.
  """
  @spec list_executions(atom(), keyword()) :: {:ok, [Execution.t()]}
  def list_executions(workflow_name, opts \\ []) when is_atom(workflow_name) do
    name_string = Atom.to_string(workflow_name)
    limit = Keyword.get(opts, :limit, 100)
    state = Keyword.get(opts, :state)

    query =
      from(e in WorkflowExecution,
        where: e.workflow_name == ^name_string,
        order_by: [desc: e.inserted_at],
        limit: ^limit
      )

    query = maybe_filter_state(query, state)

    executions =
      query
      |> repo().all(prefix: prefix())
      |> Enum.map(&WorkflowExecution.to_execution/1)

    {:ok, executions}
  rescue
    ArgumentError ->
      {:ok, []}
  end

  @doc """
  Lists all running executions.
  """
  @spec list_running_executions(keyword()) :: {:ok, [Execution.t()]}
  def list_running_executions(opts \\ []) do
    workflow_name = Keyword.get(opts, :workflow)
    limit = Keyword.get(opts, :limit, 100)

    query =
      from(e in WorkflowExecution,
        where: e.state == "running",
        order_by: [desc: e.started_at],
        limit: ^limit
      )

    query =
      case workflow_name do
        nil -> query
        name -> from(e in query, where: e.workflow_name == ^Atom.to_string(name))
      end

    executions =
      query
      |> repo().all(prefix: prefix())
      |> Enum.map(&WorkflowExecution.to_execution/1)

    {:ok, executions}
  rescue
    ArgumentError ->
      {:ok, []}
  end

  @doc """
  Gets execution statistics.
  """
  @spec get_stats(keyword()) :: map()
  def get_stats(opts \\ []) do
    workflow_name = Keyword.get(opts, :workflow)

    # Count workflow definitions
    workflow_query = from(w in WorkflowDefinition, select: count(w.id, :distinct))
    workflow_count = repo().one(workflow_query, prefix: prefix()) || 0

    # Count executions by state
    exec_query =
      from(e in WorkflowExecution,
        group_by: e.state,
        select: {e.state, count(e.id)}
      )

    exec_query =
      case workflow_name do
        nil -> exec_query
        name -> from(e in exec_query, where: e.workflow_name == ^Atom.to_string(name))
      end

    state_counts =
      exec_query
      |> repo().all(prefix: prefix())
      |> Map.new(fn {state, count} -> {String.to_existing_atom(state), count} end)

    total = Enum.reduce(state_counts, 0, fn {_state, count}, acc -> acc + count end)

    %{
      workflows: workflow_count,
      executions: %{
        total: total,
        by_state: state_counts
      }
    }
  rescue
    ArgumentError ->
      %{workflows: 0, executions: %{total: 0, by_state: %{}}}
  end

  @doc """
  Prunes old execution records.
  """
  @spec prune_executions(keyword()) :: {:ok, non_neg_integer()}
  def prune_executions(opts \\ []) do
    before = Keyword.get(opts, :before, DateTime.add(DateTime.utc_now(), -30, :day))
    limit = Keyword.get(opts, :limit, 10_000)

    # Delete step executions first
    step_subquery =
      from(e in WorkflowExecution,
        where: e.inserted_at < ^before,
        select: e.id,
        limit: ^limit
      )

    step_query =
      from(s in WorkflowStepExecution, where: s.workflow_execution_id in subquery(step_subquery))

    {step_count, _} = repo().delete_all(step_query, prefix: prefix())

    # Then delete executions
    exec_query =
      from(e in WorkflowExecution,
        where: e.id in subquery(step_subquery)
      )

    {exec_count, _} = repo().delete_all(exec_query, prefix: prefix())

    Logger.info(
      "[Workflow.Store] Pruned #{exec_count} executions and #{step_count} step executions"
    )

    {:ok, exec_count}
  end

  # ============================================
  # Step Execution Operations
  # ============================================

  @doc """
  Records a step starting.
  """
  @spec record_step_start(String.t(), atom(), non_neg_integer()) ::
          {:ok, WorkflowStepExecution.t()} | {:error, term()}
  def record_step_start(execution_id, step_name, attempt) do
    attrs =
      WorkflowStepExecution.new(execution_id, step_name)
      |> WorkflowStepExecution.start(attempt)

    # Upsert - update if exists, insert if not
    case get_step_execution(execution_id, step_name) do
      {:ok, schema} ->
        schema
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().update(prefix: prefix())

      {:error, :not_found} ->
        %WorkflowStepExecution{}
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().insert(prefix: prefix())
    end
  end

  @doc """
  Records a step completing.
  """
  @spec record_step_complete(String.t(), atom(), term()) ::
          {:ok, WorkflowStepExecution.t()} | {:error, term()}
  def record_step_complete(execution_id, step_name, result) do
    case get_step_execution(execution_id, step_name) do
      {:ok, schema} ->
        # Convert schema to map, apply complete transformation, then update
        attrs =
          schema
          |> Map.from_struct()
          |> WorkflowStepExecution.complete(result)

        schema
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().update(prefix: prefix())

      {:error, :not_found} ->
        # Create with completed state
        attrs =
          WorkflowStepExecution.new(execution_id, step_name)
          |> WorkflowStepExecution.start()
          |> WorkflowStepExecution.complete(result)

        %WorkflowStepExecution{}
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().insert(prefix: prefix())
    end
  end

  @doc """
  Records a step failing.
  """
  @spec record_step_failed(String.t(), atom(), term(), String.t() | nil) ::
          {:ok, WorkflowStepExecution.t()} | {:error, term()}
  def record_step_failed(execution_id, step_name, error, stacktrace \\ nil) do
    case get_step_execution(execution_id, step_name) do
      {:ok, schema} ->
        # Convert schema to map, apply fail transformation, then update
        attrs =
          schema
          |> Map.from_struct()
          |> WorkflowStepExecution.fail(error, stacktrace)

        schema
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().update(prefix: prefix())

      {:error, :not_found} ->
        # Create with failed state
        attrs =
          WorkflowStepExecution.new(execution_id, step_name)
          |> WorkflowStepExecution.start()
          |> WorkflowStepExecution.fail(error, stacktrace)

        %WorkflowStepExecution{}
        |> WorkflowStepExecution.changeset(attrs)
        |> repo().insert(prefix: prefix())
    end
  end

  @doc """
  Lists step executions for a workflow execution.
  """
  @spec list_step_executions(String.t()) :: {:ok, [WorkflowStepExecution.t()]}
  def list_step_executions(execution_id) do
    query =
      from(s in WorkflowStepExecution,
        where: s.workflow_execution_id == ^execution_id,
        order_by: [asc: s.started_at]
      )

    {:ok, repo().all(query, prefix: prefix())}
  end

  defp get_step_execution(execution_id, step_name) do
    name_string = to_string(step_name)

    query =
      from(s in WorkflowStepExecution,
        where: s.workflow_execution_id == ^execution_id,
        where: s.step_name == ^name_string
      )

    case repo().one(query, prefix: prefix()) do
      nil -> {:error, :not_found}
      schema -> {:ok, schema}
    end
  end

  # ============================================
  # Private Helpers
  # ============================================

  defp maybe_filter_tags(query, []), do: query

  defp maybe_filter_tags(query, tags) do
    from(w in query, where: fragment("? && ?", w.tags, ^tags))
  end

  defp maybe_filter_trigger(query, nil), do: query

  defp maybe_filter_trigger(query, trigger_type) do
    from(w in query, where: w.trigger_type == ^to_string(trigger_type))
  end

  defp maybe_filter_enabled(query, nil), do: query

  defp maybe_filter_enabled(query, enabled) do
    from(w in query, where: w.enabled == ^enabled)
  end

  defp maybe_filter_state(query, nil), do: query

  defp maybe_filter_state(query, state) when is_atom(state) do
    from(e in query, where: e.state == ^to_string(state))
  end
end
